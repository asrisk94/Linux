
root 접속 psudo 명령어

사용자 관리, 파일속성

새로운 사용자 추가 useradd, adduser

usermod 사용자 속성 변경



파일, 디렉토리 소유 허가권 (ls -l 정보)

파일 허가권 변경 chmod

파일 소유권 변경 chown

링크 (하드 링크 / 심볼릭 링크)



RPM (프로그램 설치 명령어)

YUM (프로그램 설치 명령어)

YUM 고급 사용법

YUM 작동방식
YUM 설정파일



파일 압축 xz bzip gzip zip 

파일 묶기 tar

파일 위치 검색 find which whereis locate



cron

at



	네트워크 설정 및 명령어

host name

ip

네트워크 주소

브로드캐스트 주소

게이트웨이

넷마스크

클래스



DNS

리눅스 네트워크 장치 이름

네트워크 관련 중요 명령어 nmtui systemctl nslookup ping IP

네트워크 주요 설정 파일

SELinux



파이프

필터

리다이렉션

프로세스

데몬

서비스

소켓



	셸

셸 환경변수

셸 스크립트 작성

셸 스크립트 실행

셸 변수

파라미터 변수

if문

case문

AND, OR 연산자

for~in 문

while문

until문

break, continue, exit, return

셸 사용자정의 함수

셸 함수 파라미터 사용

eval

export

printf

set, $(명령어)

shift



	네트워크 서버

텔넷 서버

OpenSSH 서버




================================================================================

root 접속 psudo 명령어


su -
패스워드

$ 표시에서 # 표시로 바뀌면 성공.
사용 후 exit 명령어로 로그아웃 (일반 계정으로 돌아감)

-------------------------------------------------------------------

사용자 관리, 파일속성

vi /etc/passwd	사용자이름 : 암호 : 사용자ID : 사용자소속그룹ID : 전체이름 : 홈디렉토리 : 기본셸

vi /etc/group	그룹이름 : 비밀번호 : 그룹ID : 그룹에속한 사용자 이름

-------------------------------------------------------------------

새로운 사용자 추가 useradd, adduser

useradd newuser		newuser 이름의 새로운 사용자 생성

useradd -u 1111 newuser		newuser 사용자 생성하면서 사용자ID 를 1111로 지정

-g mygroup		생성하면서 mygroup에 사용자 포함시킴 (mygroup) 존재해야함)

-d /newhome		사용자 생성하면서 홈 디렉토리를 /newhome으로 지정

-s /bin/csh		사용자 생성하면서 기본 셸을 /bin/csh로 지정

---------------------------------------------------------------------

usermod 사용자 속성 변경

usermod -g root newuser		사용자 비밀번호 지정 또는 변경

-----------------------------------------------------------------------

파일, 디렉토리 소유 허가권 (ls -l 정보)



ls -l (또는 ll)
-rw-r--r-- 1 root root 1525 11월 28 14:55 sample.txt

  첫자리 : 파일 유형
디렉토리(d) / 일반파일(-) / 블록 디바이스(b) / 문자 디바이스(c) / 링크(l) 등

*   ls -l /dev | more 실행시 b, c 많이 보임
b는 하드디스크, CD 등 / c는 마우스, 키보드, 프린터 등 / l은 윈도우 바로가기 아이콘과 비슷

  2~10 : 파일 허가권
rwx순이고 3번반복. (r은 read / w는 write / x는 execute) 
2진법으로 111 100 101 등으로 가능하기 때문에 순서대로 4, 2, 1의 값을 각각 갖는다.
합쳐서 6 이렇게도 표시(4+2이므로 읽기쓰기 가능)
3번 반복이므로 사용자.그룹.사용자외그룹 순서.



파일 허가권 변경 chmod 

chmod 754 sample.txt	-> 사용자(읽쓰실) 그룹(읽실) 외그룹(읽) 권한을 sample.txt 파일에 대해 부여



파일 소유권 변경 chown

chown 새로운사용자이름(,새로운그룹이름) 파일잉름

chown centos.centos sample.txt	-> 파일소유자를 centos로 변경 / 파일그룹을 centos로 변경

--------------------------------------------------------------------------------------------------------------------

링크 (하드 링크 / 심볼릭 링크)


하드링크 : inode 공유. 하드링크파일 생성.
ln 링크대상파일이름 링크파일이름

심볼릭링크 : inode 새로 만듦. 데이터는 원본 파일 포인팅. (윈도우 바로가기 아이콘 느낌)
ln -s 링크대상파일이름 링크파일이름

*   inode : 리눅스/유닉스 파일시스템 자료구조. (파일이나 디렉토리마다 하나씩 존재) 
	파일이나 디렉토리 관련 여러 정보 담김.
	파일 소유권, 허가권, 파일 종류, 해당파일 실제 데이터 위치 등 (inode 블록은 전체 디스크의 1%정도 차지. 나머지는 데이터 블록)

* 하드링크는 파일 위치가 바뀌어도 항상 존재. 소프트링크는 그 자리에 있어야함. 용량은 소프트링크가 훨씬 덜먹음 (딱 이 차이임)

------------------------------------------------------------------------------------------------------------------

RPM (프로그램 설치 명령어)

YUM 나오기 이전 명령어. Windows의 .exe 느낌. 
.rpm이 설치파일 확장명. 이를 '패키지'라고 부른다.


일반적인 rpm파일 패키지 형식
패키지이름-버전-릴리스번호.CentOS버전.아키텍처.rpm	ex) gedit-3.8.3-6.el7.x86_64.rpm

--------------------

자주 사용하는 rpm 명령어 옵션

  설치 : rpm -Uvh 패키지파일이름.rpm

U -> 기존에 패키지가 설치되지 않았다면 일반적인 설치. 설치되어있다면 업그레이드 (i옵션은 설치되어있었다면 오류남)
v -> 설치 과정확인
h -> 설치 진행 과정을 #기호로 화면에 출력

  삭제 : rpm -e 패키지이름

e -> erase(지움)의 약자

이미 설치된 패키지 조회

rpm -qa 패키지이름	-> 시스템에 패키지가 설치되었는지 확인
rpm -qf 파일절대경로 	-> 이미 설치된 파일이 어느 패키지에 포함된 것인지 확인
rpm -ql 패키지이름	-> 특정 패키지에 어떤 파일들이 포함되었는지 확인
rpm -qi 패키지이름	-> 설치된 패키지의 상세 정보

아직 설치되지 않은 rpm 파일 조회 

rpm -qlp 패키지파일이름.rpm	-> 패키지 파일에 어떤 파일들이 포함되었는지 확인
rpm -qip 패키지파일이름.rpm	-> 패키지 파일의 상세정보

* rpm에는 의존성 문제가 있어 이를 해결한 YUM을 더 많이 사용함.

------------------------------------------------------------------------------------

YUM (프로그램 설치 명령어)

특정패키지를 설치하고자할 때 의존성 있는 다른 패키지를 자동으로 먼저 설치해주는 기능을 갖춘 명령어. (RPM 상위호환)

필요한 파일은 인터넷을 통해 자동으로 다운받아 설치하므로, 인터넷 연결만 되어있다면 파일을 일일히 갖출 필요가 없다.
(저장소 URL은 /etc/yum.repos.d/ 디렉토리의 파일에 저장되어 있다.)


기본 사용법

기본 설치
yum -y install 패키지이름

yum install은 패키지 다운로드 후 사용자에게 설치 여부를 묻는 부분이 나온다.
-y를 달아주면 yes/no에서 무조건 yes를 잡고 넘어가주므로 편리.

rpm파일 설치방법
yum localinstall rpm파일이름.rpm

업데이트 가능목록 보기
yum check-update

업데이트
yum update 패키지이름
(yum install 하면 upsert 되기 때문에 사실 필요 없다.)

삭제
yum remove 패키지이름

정보확인
yum info 패키지이름

-------------------------------------------------------------------

YUM 고급 사용법



패키지 그룹설치
yum groupinstall "패키지그룹이름"

패키지 그룹 종류
yum grouplist "패키지그룹이름"
(설치할 때 패키지 그룹 이름은 주로 띄어쓰기가 많아 꼭 ""안에 써야한다)

패키지 리스트 확인
yum list 패키지이름	(ex. yum list all (전부) / yum list httpd (httpd가 들어간 것들) / yum list available (설치 가능한 것들) )

특정 파일이 속한 패키지 이름
yum provides 파일이름

GPG 키 검사 생략
yum install -nogpgcheck rpm파일이름.rpm
(CentOS7에서 인증되지 않은 rpm파일을 yum localinstall로 설치하면 안되는 경우가 있는데 이를 통과하는 방법)

기존 저장소 목록 지우기
yum clean all
(기존 다운로드 패키지 목록 지우고 다시 yum install하면 새로 패키지 목록 다운로드)

---------------------------------------------------------------------------------------------------

YUM 작동방식
YUM 설정파일

 yum 명령어 관련 설정 파일 -> /etc/yum.conf	/etc/yum.repos.d/ 디렉토리 존재.

conf파일은 특별히 설정할 것 없음.
repos.d 디렉토리에 있는 여러 파일은 중요. 
-> 각 파일은 yum 명령어 실행시 인터넷에서 해당 패키지파일을 검색하는 네트워크 주소 담고 있음.


yum 작동방식

1. yum install 입력
2. repos.d 디렉토리내 repo파일을 통해 	저장소 URL 확인
3. 해당 URL을 통해 CentOS 패키지 저장소에 접근하여 	전체 패키지 목록 요청
4. 패키지 목록이 담긴 파일 다운로드
5. 화면에 출력
6. y로 허락맡고 설치에 필요한 	패키지 파일 다시 저장소에 요청
7. 다운로드하여 	자동 설치

CentOS-Base.repo 파일의 updates 부분을 삭제하지 않으면 알아서 업데이트 패키지 저장소의 파일을 사용.
삭제했다면 원본 패키지 저장소의 파일을 사용할 것임.
* 해당 파일에는 저장소 원천과 경로 등 여러 설정이 있으므로 필요시 검색해볼 것.

----------------------------------------------------------------------------------------------

파일 압축 xz bzip gzip zip 

xz	확장명 xz로 압축하거나 해제. (비교적 최신 압축 명령. 효율 좋음)
xz 파일이름		압축
xz -d 파일이름.xz 		d는 Decompress 의미. 파일이름으로 압축해제
xz -l 파일이름.xz		l은 List. 파일이름.xz 압축파일에 포함된 파일 목록과 압축률 등 출력
xz -k 파일이름		k는 keep. 압축 후 기존 파일을 삭제하지 않고 그대로 둠

bzip	확장명 bz2로 압축하거나 해제.
bzip2 파일이름	압축파일 파일이름.bzp2 생성.
bzip2 -d 파일이름.bz2	압축 해제

bunzip2		확장명 bz2의 압축 해제. bzip2 -d와 같은 명령어.

gzip	확장명 gz로 압축 또는 해제
gzip 파일이름		압축
gzip -d 파일이름.gz	압축해제

gunzip		gzip -d와 동일

zip	windows용과 호환되는 확장명 zip으로 압축 또는 해제
zip 생성할파일이름.zip 압축할파일이름	

unzip	windows용과 호환되는zip으로 묶은 압축파일 해제

-----------------------------------------------------------------------------

파일 묶기 tar

윈도우는 압축 프로그램이 압축시 파일묶기와 압축을 동시에 해줌.
리눅스는 별도로 존재. (사용자 편의성을 위해 한 번에 할 수 있는 옵션도 존재)

파일 묶기 명령어 : tar (확장명도 tar)

동작
c(소문자)		새로운 묶음을 만든다.
x		묶인 파일을 푼다.
t		묶음을 풀기 전에 묶인 경로를 보여준다.
C(대문자)		묶음을 풀 때 지정된 디렉토리에 압축을 푼다.
		지정하지 않으면 묶을 때와 동일한 디렉토리에 묶음이 풀린다.

옵션
f(필수)		묶음 파일 이름 지정. 원래 tar는 테이프 장치 백업이 기본. (생략하면 테이프로 보내짐)
v		visual의 의미. 파일이 묶이거나 풀리는 과정 보여줌
J(대문자)		tar + xz
z(소문자)		tar + gzip
j(소문자)		tar + bzip2

예시
tar cvf my.tar /etc/sysconfig/		묶기
tar cvfJ my.tar.xz /etc/sysconfig/	묶기 + xz 압축
tar tvf my.tar			파일 확인
tar xvf my.tar			taf 풀기
tar Cxvf newdir my.tar		newdir에 tar 풀기
tar xfz my.tar.gz			gipz 압축 해제 + tar 풀기

------------------------------------------------------------------------------------

파일 위치 검색 find which whereis locate

find 
옵션 : -name / -user(소유자) / -newer(전, 후) / -perm(허가권) / -size(크기)
액션 : -print(기본값) / -exec(외부 명령 실행)

기본 사용 예시
find /etc -name "*.conf"		/etc 디렉토리 하위에 확장명이 .conf인 파일 검색
find /home -user centos		/home 디렉토리 하위에 소유자가 centos인 파일 검색
find ~ -perm 644			현재 사용자의 홈디렉토리 하위에 허가권이 644인 파일 검색
find /usr/bin -size +10k -size -100k	/usr/bin 디렉토리 하위에 파일크기 10KB ~ 100KB인 파일 검색

고급 사용 예시
find ~ -size 0k -exec ls -l { } \;	현재 사용자의 홈 디렉토리 하위에 파일크기 0인 파일의 목록 상세히 출력
find /home -name "*swp" -exec rm { } \;	/home 홈 디렉토리 하위 확장명이 *.swp인 파일 삭제

-exec : 외부 명령어 시작
\; : 외부 명령어 끝
{ } : -exec 이전 find로 끌어낸 파일들 의미

which 실행파일이름	PATH에 설정된 디렉토리만 검색
whereis 실행파일이름	실행 파일, 소스, man 페이지 파일까지 검색
locate 파일이름		파일 목록 데이터베이스에서 검색하기 때문에 매우 빠르고 유용하지만, updatedb 명령어를 1회 실행해야 사용가능.
			또 updatedb 명령어 실행 이후 설치된 파일은 찾을 수 없으므로 다시 updatedb 실행해야 찾을 수 있음.

-------------------------------------------------------------------------------------

cron



주기적 반복 작업 수행 예약 : cron
cron과 관련된 데몬(서비스) : crond
관련 파일 : /etc/crontab

/etc/crontab 형식 
분 시 일 월 요일 사용자 실행명령

0~59	0~23	1~31	1~12	0~6(일요일부터 시작)	(명령을 실행할)사용자	그 시간에 실행할 명령

ex) 00 05 1 * * root cp -r /home /backup
-> (요일 상관x) 매월 1일 새벽 5시에 root 계정으로 cp =r /home /backup 실행



* cron은 주기적으로 실행할 내용을 디렉토리에 넣어 놓고 작동.

/etc/crontab 파일  	- 시간별 : /etc/cron.hourly/
		- 일별    : /etc/cron.daily/
		- 주별    : /etc/cron.weekly/
		- 월별    : /etc/cron.monthly/

/etc/crontab 파일 내에 호출 디렉토리를 볼 수 있다.

ex) 01 * * * * root run-parts /etc/conr.hourly			* run-parts 명령어는 자신 다음에 나오는 디렉토리 안 명령어를 모두 수행.

----------------------------------------------------------

at

cron은 주기적 반복 작업 예약
at 명령어는 일회성 작업 예약

ex)
at 3:am tomorrow		- 내일 새벽 3시
at 11:00pm January 30	- 1월 30일 오후 11시
at now+1 hours		- 1시간 후

예약 : at 시간
완료시 : Ctrl + D
확인 : at -l
취소 : atrm 작업번호

ex)
프롬프트에서
at 4:00 am tomorrow	(엔터)		- 내일 오전 4시 작업 예약
yum -y update		(엔터)		- yum 명령어로 update 작업하고
reboot			(엔터)		- 완료되면 시스템 재부팅
Ctrl + D			(엔터)		- 까지 작업한다 (at로 예약할 작업 내용 작성완료)
at -l			(엔터)		- at 예약된 작업목록 확인	( ex.    3  Sun  Dec  7  04:00:00  2014  a  root)
atrm 작업번호		(엔터)		- 이 경우에는 atrm 3  -> 위에서 예약된 3번 작업 취소
at -l			(엔터)		- 예약된 작업목록이 아무것도 뜨지 않는다. (취소되었기 때문에)



------------------------------------------------------------

네트워크 설정 및 명령어

----------

 host name : 각각의 컴퓨터에 지정된 이름

----------

 - IP : 네트워크에 연결된 모든 컴퓨터는 고유한 IP 주소가 있으며, 이는 서로 다르기 때문에 특정 컴퓨터의 IP 주소를 알면,
     그 컴퓨터가 전 세계 어디에 있든지 접속할 수 있다는 개념
	ex) 서버 ip는 192.168.111.100  /  모든 컴퓨터에서 자기 자신을 가리키는 ip 127.0.0.1

----------

 - 네트워크 주소 : 같은 네트워크에 속해 있는 공통 주소
  ex)	server : 192.168.111.100
	server(B) : 192.168.111.200
	Client : 192.168.111.131
	호스트 컴 : 192.168.111.1
	이 때 서브넷 마스크는 C 클래스(255.255.255.0)를 사용하므로
	공통 네트워크 주소는 앞 3자리인 192.168.111.0

@ 192.168.xxx.ooo 주소는 사설네트워크 주소(외부 분리된 영역).

----------

 - 브로드캐스트 주소 : 내부 네트워크의 모든 컴퓨터가 수신하는 주소
		현재 주소의 제일 끝자리를 255로 바꾼 주소 (C 클래스의 경우)
	
	브로드캐스트 주소는 아파트 확성기라고 생각하면 된다.
	모두가 들을 수 있지만, 모두 응답하지는 않는다. 자신과 관련 있는 경우만 응답한다.

----------

 - 게이트웨이 : 내부 네트워크를 외부로 연결하는 컴퓨터 또는 장비
		내부 네트워크끼리 통신할 때에는 게이트웨이가 없어도 되지만, 
		인터넷을 사용하기 위해 외부와 접속하려면 반드시 게이트웨이의 IP 주소를 알아야 한다.
		외부 네트워크로 나가는 통로이며, 내부로 향하는 문(네트워크 카드), 외부로 향하는 문(네트워크 카드)이 있어야 하므로
		네트워크 카드가 2개 장착되어 있어야 한다.

@ 실무에서 게이트웨이 주소 마지막 숫자는 보통 254, 253, 1을 제일 많이 사용한다. 네트워크 관리자 마음.

게이트웨이 별도 추가 명령어
route add default gw 게이트웨이주소 dev 장치이름	ex) 뒤가 254로 변경된 경우 route add default gw 192.168.111.254 dev ens32

----------

 - 넷마스크 : 네트워크의 규모를 결정 

넷마스크 C 클래스 : 255.255.255.0	B클래스 : 255.255.0.0	A클래스 : 255.0.0.0

C클래스의 경우 
ex) 192.168.111.0 ~ 192.168.111.255까지 256대의 컴퓨터를 할당해 사용할 수 있지만,
192.168.111.0은 네트워크 주소 / 192.168.111.255는 브로드캐스트 주소 / 192.168.111.2는 게이트웨이로 사용할 IP 주소
이렇게 배제하면 총 253대의 ip를 등록하여 사용할 수 있다.

B 클래스는 192.168.0.0이 네트워크 주소가 되고 2의 16제곱 갯수의 컴퓨터 ip를 등록하여 사용할 수 있다.
A 클래스는 192.0.0.0		

------------------------------------------------------------------------------------------------------------------------

DNS

www.daum.net과 같은 URL을 해당 컴퓨터 IP 주소로 변환해주는 서버 프로그램

DNS 서버의 주소를 사용하지 않거나 잘못 입력되어 있으면 정상적으로 웹사이트에 접속되지 않음.

설정파일	-> /etc/resolv.conf
내용 중에 'nameserver DNS서버IP' 형식으로 설정되어야 함.

----------------------------------------------------------------------------------------------------------------

리눅스 네트워크 장치 이름

리눅스에 랜카드 장착시 이름은 자동으로 ens32, ens33 등으로 잡힘
이 이름은 네트워크 정보 파악, 정지, 가동 때 사용.
ex)
ifconfig ens32(ens33)	- 네트워크 설정 정보를 출력
ifup ens32(ens33)		- 네트워크 장치를 가동
ifdown ens32(ens33)	- 네트워크 장치를 정지

---------------------------------------------------------------------------------------------------------

네트워크 관련 중요 명령어 nmtui systemctl nslookup ping IP 



 - nmtui (Network Manager Text User Interface)

네트워크와 관련된 작업 대부분이 이 명령어를 기반으로 삼아 실행될 수 있다.

1. 자동 IP 주소 도는 고정 IP 주소 사용 결정
2. IP 주소, 서브넷마스크, 게이트웨이 정보 입력
3. DNS 정보 입력
4. 네트워크 카드 드라이버 설정
5. 네트워크 장치(ens32 또는 ens33)의 설정



 - systemctl start/stop/restart/status network

네트워크 설정 변경 후 변경내용 적용하는 명령어.



 - nslookup

DNS 서버 작동을 테스트하는 명령어.



 - ping IP(또는 URL) 

해당 컴퓨터가 네트워크상에서 응답하는지 테스트.
상대 컴퓨터가 이상 없이 작동하는지 네트워크상에서 체크할 때 주로 사용

-----------------------------------------------------

네트워크 주요 설정 파일

@ nmtui 명령어 실행 후 변경되는 관련 파일들 

 - /etc/sysconfig/network
네트워크 기본 정보가 설정되어 있는 파일. 네트워크 사용 여부 기록되어 있음

 - /etc/sysconfig/network-scripts/ifcfg-ens32(또는 ens33 또는 릴리즈서버는 eth0였음)
ens32 장치에 설정된 네트워크 정보가 모두 들어있는 파일.

 - /etc/resolv.conf
DNS 서버의 정보와 호스트 이름이 들어있는 파일.

 - /etc/hosts
현 컴퓨터의 호스트 이름과 FQDN이 들어있는 파일.
	@ FQDN (Full Qualified Domain Name) : 전체 주소 도메인 네임
	SSL 인증서 신청시 CN이나 멀티도메인의 추가도메인에 포함되는 도메인은 FQDN 형식으로 입력해야 한다.

-> nmtui 명령어를 사용하지 않아도 위 4개 파일을 직접 편집하면 동일한 효과를 낼 수 있다.

----------------------------------------------------------------------------------------------------------

SELinux

리눅스 보안을 위해 탄생. 시스템에서 보안에 영향을 미치는 서비스, 권한 등을 제어 가능.
어떤 경로로 침입하든 침입한 경로의 어플리케이션 사용 이상의 권한을 얻지 못한다.

SELinux 사용 여부는 강제(enforcing), 허용(permissive), 비활성(disabled)이라는 3가지 레벨을 지원한다.

/etc/sysconfig/selinux 파일로 설정.	-> system-config-selinux 명령어로도 설정 가능. (policycoreutils-gui 패키지 설치 필요)

설정 후 재부팅 필요

------------------------------------------------------------------------------------------------------------

파이프, 필터, 리다이렉션



 - 파이프 : 2개의 프로그램을 연결해주는 연결 통로

| 사용. (shift + \)

ex)
ls -l /etc | more	->	ls -l /etc 입력시 파일이 너무 많아 1페이지씩 나눠서 보겠다는 의미.



 - 필터 : 필요한 것만 걸러주는 명령어

grep, tail, wc, sort, awk, sed 명령어 등이 존재. (주로 파이프와 함께 사용)

ex)
ps -ef | grep bash	-> ps -ef 입력시 모든 프로세스 번호 호출. 여기서 bash라는 글자가 들어간 프로세스만 출력.

rpm -qa | grep yum	-> 설치된 패키지 중에서 yum 글자가 들어간 패키지만 출력.
			    그냥 rpm -qa yum 실행하면 yum-utils는 출력되지 않는다.



 - 리다이렉션 : 표준 입출력 방향을 바꿔준다.

표준 입력은 키보드, 표준 출력은 모니터이지만 이를 파일로 처리하고 싶을 때 주로 사용.

ex)
ls -l > list.txt	-> ls -l의 결과를 화면이 아닌 list.txt 파일에 저장 (기존에 있으면 덮어쓴다)
ls -l >> list.txt	-> 위와 동일하나, 기존에 존재하면 기존 내용에 이어서  쓴다 (append)

sort < list.txt	-> list.txt 파일을 정렬해서 화면에 출력.
sort < list.txt > out.txt	-> list.txt 파일을 정렬해서 out.txt 파일에 쓴다.

------------------------------------------------------------------------------------------------------------------

프로세스

하드디스크에 저장된 실행 코드(프로그램)가, 메모리에 로딩되어 활성화된 것.

 - 포어그라운드 프로세스 : 사용자와 상호작용하는 프로세스. 화면에 보이는 것.
 - 백그라운드 프로세스 : 실행은 되었지만 화면에는 나타나지 않고 뒤에서 실행되는 프로세스.

 - 프로세스 번호 : 프로세스를 구분하기 위한 각각의 고유 번호.
   메모리에서 활성화된 프로세스를 메모리에서 강제로 제거하려면 프로세스 번호를 사용해야함.

 - 작업번호 : 현재 실행되는 백그라운드 프로세스의 순차 번호

 - 부모 프로세스, 자식 프로세스
   모든 프로세스는 독립적 실행이 아니라 부모 프로세스의 하위에 종속되어 실행된다.
   부모를 종료하면 자식도 같이 종료된다.

프로세스 명령어

ps 	현재 프로세스의 상태를 확인.
ps -ef | grep 프로세스이름		프로세스 번호 및 상태 확인

kill	프로세스 강제 종료 명령어.
kill -9 프로세스번호		무조건 프로세스 종료

pstree	부모 프로세스와 자식 프로세스 관계 트리형태로 보여줌

----------------------------------------------------------------------------------------------------------

데몬

서비스

데몬이라고도 부르는 서비스는 서버 프로세스를 의미.
즉 웹 서버, 네임 서버, DB 서버 등의 프로세스를 지칭. (웹 서버 데몬, 네임 서버 데몬 등으로 부르기도 한다)

눈에 보이지 않지만 현재 동작중이므로 백그라운드 프로세스의 일종이라고 할 수 있다.

-----------------------------------------------------------------------------------------

소켓

서비스는 평상시에도 늘 가동하는 서버 프로세스.
소켓은 필요할 때만 작동하는 서버 프로세스.

서비스와 소켓은 systemd라고 부르는 서비스 매니저 프로그램으로 작동, 관리한다.



@ 서비스, 소켓 비교

서비스

시스템과 독자적으로 구동되어 제공하는 프로세스	ex) 웹서버(httpd), DB 서버(mysqld), FTP 서버(vsftpd) 등
실행 및 종료 : systemctl start/stop/restart/status
서비스 실행 스크립트파일 : /usr/lib/systemd/system/ 디렉토리에 '서비스이름.service' 라는 이름으로 확인 가능.
ex) 웹  서비스 : httpd.service
* systemctl list-unit-files 실행시, 부팅과 동시 자동실행여부 설정 가능. 현재 사용과 사용 안함 확인 가능.
  상태(STATE)가 static으로 설정된 것은 따로 설정 변경 불가.

소켓

소켓은 외부에서 특정 서비스를 요청할 경우에 systemd가 구동. 요청이 끝나면 소켓도 종료.
systemd가 서비스를 새로 구동하는 데 시간이 소요되기 때문에, 소켓 처음 연결시 소요시간이 조금 더 길 수 있다. ex) 텔넷 서버
소켓 관련 스크립트 파일 : /usr/lib/systemd/system/ 디렉토리에 '소켓이름.socket' 이라는 이름으로 확인 가능.

-------------------------------------------------------------------------------------------------------------------------------

셸

CentOS 기본 셸 : bash (Bourne Again SHell)

bash 특징 : Alias / History / 연산 / Job Control / 자동 이름 완성 / 프롬프트 제어 / 명령 편집

셸 명령문 처리 방법 : (프롬프트) 명령어 [옵션...] [인자...]



셸 환경변수

echo $환경변수이름 	형식으로 명령어 실행하여 확인 가능

ex) echo $HOSTNAME	-> 호스트 이름 출력

주요 환경변수
HOME 		현재 사용자 홈 디렉토리		PATH		실행 파일을 찾는 디렉토리 경로
LANG 		기본 지원되는 언어			PWD		사용자의 현재 작업 디렉토리	
TERM 		로그인 터미널 타입			SHELL		로그인해서 사용하는 셸
USER 		현재 사용자 이름			DISPLAY		X 디스플레이 이름
COLUMNS 	현재 터미널 컬럼 수	 	LINES		현재 터미널 라인 수
PS1 		1차 명령 프롬프트 변수		PS2		2차 명령 프롬프트 (대개는 '>')
BASH 		bash 셸의 경로			BASH_VERSION	bash 버전
HISTFILE		히스토리 파일의 경로		HISTSIZE		히스토리 파일에 저장되는 개수
HOSTNAME 	호스트의 이름			USERNAME	현재 사용자 이름
LOGNAME	로그인 이름			LS_COLORS	ls 명령어 확장자 색상 옵션
MAIL		메일을 보관하는 경로		OSTYPE		운영체제 타입

환경변수값 변경시
export 환경변수=값

그 외 환경변수값 출력은 printenv로 출력

---------------------------

셸 스크립트 작성

ex)
#! /bin/sh				#!은 특별한 형태의 주석. bash를 사용하겠다는 의미이며 첫 행에 꼭 써야함.
echo "사용자 이름 : " $USERNAME		echo 명령어는 화면에 출력하는 명령. 사용자 이름 : 출력하고 $USERNAME 환경변수에 담길 내용 입력
echo "호스트 이름 : " $HOSTNAME		위와 동일 개념
exit 0					종료코드 반환. 타 스크립트에서 이 스크립트 호출 후 제대로 실행되었는지 확인할 때 활용.
					셸 스크립트는 실행 중간에 문제가 생겨도 무조건 성공했다는 메시지를 반환하므로
					마지막 행에서 성공인지 실패인지 반환하는 것이 좋다. 0은 성공.



셸 스크립트 실행 

1) " sh 스크립트파일 "
2) 파일 속성을 '실행 가능'으로 바꾼 뒤 " ./스크립트파일 "

@ chmod +x 파일명 	-> 현재 파일 속성에 '실행 가능' 추가

@ 셸 스크립트를 다른 사용자도 쓸 수 있게 하려면 /usr/local/bin 디렉토리에 복사 후 755 권한을 부여해야 한다.
ex)
cp name.sh /usr/local/bin/
chmod 755 /usr/local/bin/name.sh
su - centos
name.sh (실행됨) ~~~

----------------------------------------------------------------------------------------

셸 변수

변수 기본
- 셸 스크립트에서는 변수를 사용하기 전에 미리 선언 x. 
- 변수값 할당시 자동 변수 생성.
- 변수 넣는 모든 값은 문자열로 취급. (숫자를 넣어도 문자 취급)
- 변수 이름은 대소문자를 구분. 즉, $aa라는 변수 이름과 $AA라는 변수 이름은 다르다.
- 변수를 대입할 때 '=' 좌우에는 공백이 없어야 한다.
- 변수 이름에 띄어쓰기를 할 때에는(공백이 포함될 때에는) ""로 묶어주어야 한다.


변수 입출력
ex)

#! /bin/sh
myvar="Hi Woo"
echo $myvar
echo "$myvar"
echo '$myvar'
echo \$myvar
echo 값 입력 :
read myvar
echo '$myvar' = $myvar
exit 0

sh var1.sh			실행
Hi Woo				변수값 출력
Hi Woo				변수값 출력 (공백 포함)
$myvar				' '내부는 문자그대로로 인식하게 한다.
$myvar				\는 뒤에 나오는 $를 글자 그대로 인식하게 한다.
값 입력 :				
안녕하세요?			read는 값을 입력받아 변수에 삽입
$myvar = 안녕하세요?		



숫자 계산
	+ - * / 등의 연산을 하려면 expr 키워드를 사용해야 한다.
	단, 수식과 함께  꼭 키보드 숫자 1 왼쪽 역따옴표로 묶어야 한다. ( ` )
	수식에 괄호를 사용하려면 그 앞에 꼭 역슬래시( \ )를 붙여줘야 한다.
	또 + - /와 달리 * 기호도 예외적으로 \ 기호를 붙여줘야 한다.

#! /bin/sh
num1=100					
num2=$num1+200
echo $num2					출력
num3=`expr $num1 + 200`
echo $num3					출력
num4=`expr \($num1 + 200 \) / 10 \* 2`
echo $num4`					출력
exit 0

sh num.sh
100+200			expr 달아주지 않았기 때문에 문자취급
300			expr 존재. ` `로 감쌌음
60			괄호, 곱셈, 계산식선언 다 잘 되었음.

--------------------------------------------------------

파라미터 변수

파라미터 변수는 $0 $1 $2 등의 형태를 갖는다.

ex)
#! /bin/sh
echo "실행파일 이름은 <$0>이다."
echo "첫 번째 파라미터는 <$1>이고, 두 번째 파라미터는 <$2>이다."
echo "전체 파라미터는 <$*>이다."
exit 0

sh paravar.sh 값1 값2 값3
실행파일 이름은 <paravar.sh>이다.					$0는 실행파일 이름
첫 번째 파라미터는 <값1>이고, 두 번째 파라미터는 <값2>이다.		$1부터 셸 실행시 입력한 변수값이 차례대로 배정
전체 파라미터는 <값1 값2 값3>이다.

------------------------------------------------------------------

if문 case문

----------

if문



if [ 조건 ]
then
	참일 경우 실행
fi
* [ 조건 ]에서 모든 단어 사이에 공백이 있어야 한다.

ex)
#!/bin/sh
if [ "woo" = "woo" ]
then
	echo "참입니다"
fi
exit 0
* [ ] 대신 test 사용 가능	ex) if test "woo" = "woo"



비교 연산자

-n "문자열"		문자열이 NULL(빈 문자열)이 아니면 참
-z "문자열"		문자열이 NULL(빈 문자열)이면 참

수식1 -eq 수식2		같으면 참
수식1 -ne 수식2		같지 않으면 참
수식1 -gt 수식2		1이 크면 참
수식1 -ge 수식2		1이 크거나 같으면 참
수식1 -lt 수식2		1이 작으면 참
수식1 -le 수식2		1이 작거나 같으면 참
!수식			거짓이면 참

ex)
#!/bin/sh
if [ 100 -eq 200 ]
then
	echo "100과 200은 같다"
else
	echo "100과 200은 다르다"
fi
exit 0



파일 관련 조건

-d 파일이름	파일이 디레곹리면 참
-e 파일이름	파일이 존재하면 참
-f 파일이름	파일이 일반파일이면 참
-g 파일이름	파일에 set-group-id가 설정되면 참
-r 파일이름	파일이 읽기 가능이면 참
-s 파일이름	파일 크기가 0이 아니면 참
-u 파일이름	파일에 set-user-id가 설정되면 참
-w 파일이름	파일이 쓰기 가능 상태이면 참
-x 파일이름	파일이 실행 가능 상태이면 참

ex)
#!/bin/sh
fname=/lib/systemd/system/httpd.service			fname 변수에 웹서버 실행파일 저장
if [ -f $fname ]						fname 변수에 저장된 파일이 일반파일이면 참이므로 5행 실행
then
	head -5 $fname					
else
	echo "웹 서버가 설치되지 않았습니다."
fi
exit 0

실행결과
[Unit]
Description=The Apache HTTP Server
After=network. target remote- fs. target nss-lookup. target

[Service]

----------

case문

ex) case.sh 제작
#!/bin/sh
case "$1" in
	start)
		echo "시작~";;
	stop)
		echo "중지~";;
	restart)
		echo "다시시작~";;
	*)
		echo "뭔지 모름~";;
esac
exit 0

sh case.sh stop
중지~

각 분기에 해당하면 케이스가 걸리고,
*)의 경우 나머지 모든 경우를 의미.

ex) test.sh
#!/bin/sh
echo "리눅스 재미있나요? (yes / no)"
read answer
case $answer in
	yes | y | Y | Yes | YES)				넷 중에 하나 해당하면 인정
		echo "다행입니다"
		echo "더욱 열심히 하세요 ^^";;
	[nN]*)						앞에 n 또는 N이 들어가는 모든 단어를 인정
		echo "안타깝네요"
	*)
		echo "yes 아니면 no만 입력하세요"
		exit 1;;
esac
exit 0

sh test.sh
리눅스가 재미있나요? (yes / no)
Y
다행입니다
더욱 열심히 하세요 ^^
sh test.sh
리눅스가 재미있나요? (yes / no)
Noooo
안타깝네요

----------------------------------------------------------------

AND, OR 연산자

and : -a 또는 &&
OR : -o 또는 ||

-a나 -o는 if문 [ ] 안에 쓸 수 있는데,
이 때에는 괄호 등의 특수 문자 앞에 \(역슬래시)를 붙여줘야 한다.

------------------------------------------------------------------------

for~in 문

for 변수 in 값1 값2 값3 ---
do
	반복할 문장
done

ex)
#!/bin/sh
hap=0
for i in 1 2 3 4 5 6 7 8 9 10
do
	hap='expr $hap + $i'
done
echo "1부터 10까지의 합: "$hap
exit 0

sh forin.sh
1부터 10까지의 합: 55

ex)
#!/bin/sh
for fname in $(ls *.sh)			현재 디렉토리에 있는 셸 파일 순회
do	
	echo "-----$fname_____"
	head -3 $fname
done
exit 0

sh forin.sh
-----andor.sh-----
3줄
-----case1.sh-----
3줄
...

-----------------------------------------

while문

ex)
#!/bin/sh
whilee [ 1 ]			조건식에 1이나 [ : ] 이렇게 되면 항상 참이라 무한반복. 멈추려면 Ctrl + c
do
	echo "CentOS 7"
done
exit 0

----------------------------------------

until문

while문과 비슷. 조건식이 참이 될 때까지 반복. (조건기준만 반대)

----------------------------------------

break, continue, exit, return

break : 반복문 종료
continue : 반복문 조건식으로 돌아감
exit : 프로그램을 완전 종료 (셸)

---------------------------------------

셸 사용자정의 함수

함수이름 () {			-> 함수 정의
	내용들 ---
}

함수이름		 		-> 함수 호출

-------------------------------------

셸 함수 파라미터 사용

함수 뒤에 붙여 사용

ex)
#!/bin/sh
hap () {
	echo 'expr $1 + $2'
}
echo "10 더하기 20을 실행합니다."
hap 10 20
exit 0

sh func.sh
10 더하기 20을 실행합니다.
30

----------------------------------------------

eval

문자열을 명령문으로 인식하고 실행

ex)
#!/bin/sh
str="ls -l anaconda-ks.cfg"
echo $str
eval $str
exit 0

sh eval.sh
ls -l anaconda-ks.cfg						-> echo
-rw-------. 1 root root 1525 11월 28 14:55 anaconda-ks.cfg		-> eval

-----------------------------------------------

export

외부변수로 선언. 다른 함수에서도 쓸 수 있게 된다.

ex)
 - exp1.sh
#!/bin/sh
echo $var1
echo $var2
exit 0

 - exp2.sh
#!/bin/sh
var1="지역 변수"
export var2="외부 변수"
sh exp1.sh
exit 0

sh exp2.sh
			-> exp2.sh 지역변수값은 자기만 가지고 있어서 exp1.sh에서 호출과 동시에 선언한 변수와 다른 변수
외부 변수			-> var2는 외부변수로 선언했기 때문에 exp1.sh에서 부른 var2는 존재하는 변수이므로 값이 출력됨

------------------------------------------------

printf

형식 지정하여 출력

ex)
#!/bin/sh
var1=100.5
var2="재미있는 리눅스"					-> 공백이 있으므로 ""로 묶어줘야 함.
printf "%5.2f \n\n \t %s \n" $var1 "$var2"			-> %5.2f는 총 5자리에 소수점2자리까지 출력.
exit								$var2의 경우 값 중간 공백이 있으므로 ""로 묶어줘야 오류x

sh printf.sh
100.50

	재미있는 리눅스

---------------------------------------------

set, $(명령어)

리눅스 명령어를 결과로 사용하려면 $(명령어) 형식을 사용해야 한다.
또 결과를 파라미터로 사용하고자 할 때에는 set 명령어와 함께 사용해야 한다.

ex)
#!/bin/sh
echo "오늘 날짜는 %(date) 입니다."			-> date 명령어 실행 결과를 보여준다
set $(date)					-> 결과가 $1, $2, $3 --- 등의 파라미터 변수에 저장된다.
echo "오늘은 $4 요일 입니다."			-> 4번째 파라미터인 요일이 출력된다.
exit 0

sh set.sh
오늘 날짜는 2022. 09. 02. (금) 21:30:32 KST 입니다.
오늘은 (금) 요일 입니다.

------------------------------------------------------------

shift

파라미터 변수를 왼쪽으로 한 단계씩 아래로 쉬프트시킨다.
모든 파라미터 변수를 출력하고 싶거나, 특히 10개가 넘는 파라미터 변수에 접근할 때 사용한다.
단, $0 파라미터 변수는 변경되지 않는다.

즉 $1 = AAA	$2 = BBB 	$3 = CCC 인 상황에서
shift 실행하면 $1 = BBB 	$2 = CCC ... 이렇게 된다.

$9까지는 잘 출력되지만, $10부터는 $1 + "0" 이런 형태가 되어버리므로 왼쪽을 밀어서 사용해준다.

------------------------------------------------------------------------------------

텔넷 서버

오래된 원격 접속 방법.
보안에 취약하기 때문에 요즘에는 보안 기능을 더해서 사용.

 - 방법 기초과정

1. 텔넷 서버 설치		yum install telnet-server
2. 텔넷 서비스 시작	systemctl start telnet.socket
3. 텔넷 전용 사용자 생성	adduser 사용자이름	passwd 비밀번호
4. 방화벽 설정(포트열기)	firewall-config
5. 텔넷 서비스 상시 가동	systemctl enable telnet.socket
6. 클라이언트에서 접속	telnet 서버 IP



 - 방화벽 설정 (텍스트모드)

firewall-cmd--permanent --add-service=telnet		영구적 텔넷 허용
firewall-cmd--permanent --add-port=23/tcp		영구적 23번 tcp 포트 허용

* 영구허용이 싫으명 --permanent를 빼면 된다.
* 방화벽을 설정하고 firewall-cmd --reload 하면 방화벽 재로딩되면서 적용된다.

 - 서버 재부팅후에도 텔넷 서버 가동
systemctl enable telnet.socket



*** CentOS는 기본적으로 telnet을 통한 root 계정 접속을 허용 x
꼭 허용하고 싶다면 mv /etc/securetty /etc/securetty.bak 등을 입력하여 /etc/securetty 파일을 다른 이름으로 바꾸어 적용해제한다.

----------------------------------------------------------------------------

OpenSSH 서버

텔넷과 같은 용도이지만 보안이 강화된 서버. 리눅스에서 지원하는 서버.

텔넷은 데이터 전송시 암호화를 하지 않아 해킹 위험이 있다.
ssh 서버는 데이터 전송시 암호화한다.

OpenSSH 구축 과정

1. OpenSSH 서버 확인		systemctl status sshd
2. 방화벽 설정			firewall-config
3. 1) 리눅스 클라이언트에서 접속	ssh 사용자이름@서버IP주소
   2) windows 클라이언트에서 접속	Putty 등 SSH클라이언트 설치 -> 사용

* 패키지 설치여부 확인 	rpm -qa openssh-server
  서비스 가동여부 확인	systemctl status sshd

-----------------------------------------------------------------------------------------------------

















